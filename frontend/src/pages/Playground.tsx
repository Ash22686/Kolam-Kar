import { useState, useRef, useCallback, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  Palette,
  Undo2,
  Redo2,
  Download,
  Save,
  Grid3X3,
  Circle,
  Minus,
  RotateCcw,
  Sparkles,
  Star,
  Paintbrush,
  ZoomIn,
  ZoomOut,
  Sparkle, // Using Sparkle for Curve, as Sparkles is already used in empty state
} from "lucide-react";

const Playground = () => {
  const svgRef = useRef(null);
  const [selectedGrid, setSelectedGrid] = useState("5x5");
  const [selectedSymmetry, setSelectedSymmetry] = useState("6-fold");
  const [selectedTool, setSelectedTool] = useState("Curve");
  const [selectedColor, setSelectedColor] = useState("#45b7d1"); // Initial blue color
  const [brushSize, setBrushSize] = useState(3);
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentPath, setCurrentPath] = useState("");
  const [elements, setElements] = useState([]);
  const [history, setHistory] = useState([[]]);
  const [historyStep, setHistoryStep] = useState(0);
  const [zoom, setZoom] = useState(1);
  const [showGrid, setShowGrid] = useState(true);
  const [showSymmetryLines, setShowSymmetryLines] = useState(false);

  // For hover previews
  const [hoveredTool, setHoveredTool] = useState(null);
  const [hoveredSymmetry, setHoveredSymmetry] = useState(null);

  // Mouse tracking
  const [mouseDownPoint, setMouseDownPoint] = useState({ x: 0, y: 0 });
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });

  const gridNumber = parseInt(selectedGrid.split("x")[0]);
  const symmetryFolds = parseInt(selectedSymmetry.split("-")[0]);

  const colors = [
    "#ff6b6b",
    "#4ecdc4",
    "#45b7d1",
    "#96ceb4",
    "#ffeaa7",
    "#dda0dd",
    "#98d8c8",
    "#f7dc6f",
    "#bb8fce",
    "#85c1e9",
    "#fd79a8",
    "#00b894",
    "#e17055",
    "#a29bfe",
    "#6c5ce7",
  ];

  // Get SVG coordinates from mouse event
  const getSVGPoint = useCallback((event) => {
    if (!svgRef.current) return { x: 0, y: 0 };

    const svg = svgRef.current;
    const rect = svg.getBoundingClientRect();
    const x = ((event.clientX - rect.left) / rect.width) * 500;
    const y = ((event.clientY - rect.top) / rect.height) * 500;
    return { x, y };
  }, []);

  // Apply symmetry transformations
  const applySymmetry = useCallback(
    (element) => {
      if (symmetryFolds <= 1) return [element];

      const symmetricElements = [element];
      const centerX = 250;
      const centerY = 250;

      for (let i = 1; i < symmetryFolds; i++) {
        const angle = (360 / symmetryFolds) * i;
        const radians = (angle * Math.PI) / 180;

        let transformedElement;

        if (element.type === "path") {
          // For paths, we need to transform each point
          // This parsing needs to handle M, L, Q, C commands for more complex paths
          // For simplicity, assuming "M L" paths as generated by current tools
          const pathCommands = element.d.split(/(?=[MLQCS])/); // Split before each command
          let transformedPath = "";

          pathCommands.forEach((cmd) => {
            const type = cmd[0];
            const coordsStr = cmd.substring(1).trim();
            const coords = coordsStr
              .split(/[\s,]+/)
              .filter(Boolean)
              .map(Number);

            let newCoords = [];
            for (let j = 0; j < coords.length; j += 2) {
              const x = coords[j] - centerX;
              const y = coords[j + 1] - centerY;
              const newX =
                x * Math.cos(radians) - y * Math.sin(radians) + centerX;
              const newY =
                x * Math.sin(radians) + y * Math.cos(radians) + centerY;
              newCoords.push(newX, newY);
            }
            transformedPath += `${type}${newCoords.join(",")}`;
          });

          transformedElement = {
            ...element,
            d: transformedPath,
            id: `${element.id}-sym-${i}`,
          };
        } else if (element.type === "circle") {
          const x = element.cx - centerX;
          const y = element.cy - centerY;
          const newX = x * Math.cos(radians) - y * Math.sin(radians) + centerX;
          const newY = y * Math.cos(radians) + x * Math.sin(radians) + centerY; // Corrected rotation for y

          transformedElement = {
            ...element,
            cx: newX,
            cy: newY,
            id: `${element.id}-sym-${i}`,
          };
        } else if (element.type === "line") {
          const x1 = element.x1 - centerX;
          const y1 = element.y1 - centerY;
          const x2 = element.x2 - centerX;
          const y2 = element.y2 - centerY;

          const newX1 =
            x1 * Math.cos(radians) - y1 * Math.sin(radians) + centerX;
          const newY1 =
            y1 * Math.cos(radians) + x1 * Math.sin(radians) + centerY; // Corrected rotation for y1
          const newX2 =
            x2 * Math.cos(radians) - y2 * Math.sin(radians) + centerX;
          const newY2 =
            y2 * Math.cos(radians) + x2 * Math.sin(radians) + centerY; // Corrected rotation for y2

          transformedElement = {
            ...element,
            x1: newX1,
            y1: newY1,
            x2: newX2,
            y2: newY2,
            id: `${element.id}-sym-${i}`,
          };
        }

        if (transformedElement) {
          symmetricElements.push(transformedElement);
        }
      }

      return symmetricElements;
    },
    [symmetryFolds]
  );

  // Save to history
  const saveToHistory = useCallback(
    (newElements) => {
      const newHistory = history.slice(0, historyStep + 1);
      newHistory.push([...newElements]);
      setHistory(newHistory);
      setHistoryStep(newHistory.length - 1);
    },
    [history, historyStep]
  );

  // Mouse handlers
  const handleMouseDown = useCallback(
    (event) => {
      const point = getSVGPoint(event);
      setMouseDownPoint(point);
      setIsDrawing(true);

      if (selectedTool === "Curve" || selectedTool === "Paintbrush") {
        setCurrentPath(`M${point.x},${point.y}`);
      }
    },
    [getSVGPoint, selectedTool]
  );

  const handleMouseMove = useCallback(
    (event) => {
      const point = getSVGPoint(event);
      setMousePos(point);

      if (!isDrawing) return;

      if (selectedTool === "Curve" || selectedTool === "Paintbrush") {
        setCurrentPath((prev) => `${prev} L${point.x},${point.y}`);
      }
    },
    [getSVGPoint, isDrawing, selectedTool]
  );

  const handleMouseUp = useCallback(
    (event) => {
      if (!isDrawing) return;

      const endPoint = getSVGPoint(event);
      let newElement = null;

      if (selectedTool === "Curve" || selectedTool === "Paintbrush") {
        newElement = {
          id: `path-${Date.now()}`,
          type: "path",
          d: currentPath,
          stroke: selectedColor,
          strokeWidth: brushSize,
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
        };
      } else if (selectedTool === "Line") {
        newElement = {
          id: `line-${Date.now()}`,
          type: "line",
          x1: mouseDownPoint.x,
          y1: mouseDownPoint.y,
          x2: endPoint.x,
          y2: endPoint.y,
          stroke: selectedColor,
          strokeWidth: brushSize,
          strokeLinecap: "round",
        };
      } else if (selectedTool === "Circle") {
        const radius = Math.sqrt(
          Math.pow(endPoint.x - mouseDownPoint.x, 2) +
            Math.pow(endPoint.y - mouseDownPoint.y, 2)
        );
        newElement = {
          id: `circle-${Date.now()}`,
          type: "circle",
          cx: mouseDownPoint.x,
          cy: mouseDownPoint.y,
          r: radius,
          stroke: selectedColor,
          strokeWidth: brushSize,
          fill: "none",
        };
      }

      if (newElement) {
        const symmetricElements = applySymmetry(newElement);
        const newElements = [...elements, ...symmetricElements];
        setElements(newElements);
        saveToHistory(newElements);
      }

      setIsDrawing(false);
      setCurrentPath("");
      setMouseDownPoint({ x: 0, y: 0 });
    },
    [
      isDrawing,
      getSVGPoint,
      selectedTool,
      currentPath,
      selectedColor,
      brushSize,
      applySymmetry,
      elements,
      saveToHistory,
      mouseDownPoint,
    ]
  );

  // Grid lines
  const getGridLines = useCallback(
    (gridSize) => {
      if (!showGrid) return [];
      const spacing = 500 / gridSize;
      const lines = [];

      for (let i = 1; i < gridSize; i++) {
        const pos = i * spacing;
        lines.push(
          <line
            key={`v-${i}`}
            x1={pos}
            y1={0}
            x2={pos}
            y2={500}
            stroke="gray"
            strokeWidth="0.5"
            strokeOpacity="0.3"
          />
        );
        lines.push(
          <line
            key={`h-${i}`}
            x1={0}
            y1={pos}
            x2={500}
            y2={pos}
            stroke="gray"
            strokeWidth="0.5"
            strokeOpacity="0.3"
          />
        );
      }
      return lines;
    },
    [showGrid]
  );

  // Symmetry guide lines
  const getSymmetryLines = useCallback(() => {
    if (!showSymmetryLines) return [];
    const center = 250;
    return [...Array(symmetryFolds)].map((_, i) => {
      const angle = (360 / symmetryFolds) * i;
      const x = center + 250 * Math.cos((angle * Math.PI) / 180);
      const y = center + 250 * Math.sin((angle * Math.PI) / 180);
      return (
        <line
          key={i}
          x1={center}
          y1={center}
          x2={x}
          y2={y}
          stroke="#45b7d1" // Blue for symmetry lines
          strokeDasharray="6 4"
          strokeOpacity="0.5"
        />
      );
    });
  }, [symmetryFolds, showSymmetryLines]);

  // Action handlers
  const handleUndo = () => {
    if (historyStep > 0) {
      setHistoryStep(historyStep - 1);
      setElements(history[historyStep - 1]);
    }
  };

  const handleRedo = () => {
    if (historyStep < history.length - 1) {
      setHistoryStep(historyStep + 1);
      setElements(history[historyStep + 1]);
    }
  };

  const handleClear = () => {
    setElements([]);
    saveToHistory([]);
  };

  const handleDownload = () => {
    if (!svgRef.current) return;

    const svgData = new XMLSerializer().serializeToString(svgRef.current);
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const img = new Image();

    canvas.width = 1000;
    canvas.height = 1000;

    img.onload = () => {
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      const link = document.createElement("a");
      link.download = "kolam-design.png";
      link.href = canvas.toDataURL();
      link.click();
    };

    img.src =
      "data:image/svg+xml;base64," +
      btoa(unescape(encodeURIComponent(svgData)));
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-indigo-50">
      {/* Header */}
      <div className="bg-gradient-to-r from-blue-600 via-cyan-600 to-teal-600 py-8">
        <div className="container mx-auto px-4">
          <div className="text-center text-white">
            <div className="inline-flex items-center bg-white/20 backdrop-blur-sm rounded-full px-4 py-2 mb-4">
              <Palette className="h-4 w-4 mr-2" />
              Interactive Canvas
            </div>
            <h1 className="text-4xl lg:text-5xl font-bold mb-2">
              Kolam Playground
            </h1>
            <p className="text-white/90">
              Create mesmerizing patterns with symmetry and creativity
            </p>
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="container mx-auto px-4 py-8">
        <div className="grid lg:grid-cols-4 gap-6">
          {/* Sidebar */}
          <div className="lg:col-span-1 space-y-6">
            <div className="bg-white/80 backdrop-blur-sm rounded-2xl p-6 shadow-xl">
              <h3 className="font-bold text-lg mb-4 flex items-center">
                <Palette className="h-5 w-5 mr-2 text-blue-600" />
                Drawing Tools
              </h3>

              {/* Color Palette */}
              <div className="mb-6">
                <h4 className="font-medium mb-3">Colors</h4>
                <div className="grid grid-cols-5 gap-2">
                  {colors.map((color) => (
                    <button
                      key={color}
                      onClick={() => setSelectedColor(color)}
                      className={`w-8 h-8 rounded-full border-2 transition-all ${
                        selectedColor === color
                          ? "border-blue-800 scale-110"
                          : "border-gray-300 hover:scale-105"
                      }`}
                      style={{ backgroundColor: color }}
                    />
                  ))}
                </div>
              </div>

              {/* Brush Size */}
              <div className="mb-6">
                <h4 className="font-medium mb-3">Brush Size: {brushSize}px</h4>
                <input
                  type="range"
                  min="1"
                  max="20"
                  value={brushSize}
                  onChange={(e) => setBrushSize(Number(e.target.value))}
                  className="w-full accent-blue-600"
                />
              </div>

              {/* Grid Setup */}
              <div className="mb-6">
                <h4 className="font-medium mb-3 flex items-center">
                  <Grid3X3 className="h-4 w-4 mr-2" />
                  Grid Setup
                </h4>
                <div className="grid grid-cols-3 gap-2 mb-3">
                  {["3x3", "5x5", "7x7", "9x9", "11x11", "13x13"].map(
                    (grid) => (
                      <button
                        key={grid}
                        onClick={() => setSelectedGrid(grid)}
                        className={`px-3 py-2 rounded-lg text-sm font-medium transition-all ${
                          selectedGrid === grid
                            ? "bg-blue-600 text-white shadow-lg"
                            : "bg-gray-100 hover:bg-gray-200"
                        }`}
                      >
                        {grid}
                      </button>
                    )
                  )}
                </div>
                <div className="flex gap-2">
                  <button
                    onClick={() => setShowGrid(!showGrid)}
                    className={`flex-1 px-3 py-2 rounded-lg text-sm transition-all ${
                      showGrid ? "bg-blue-100 text-blue-700" : "bg-gray-100"
                    }`}
                  >
                    {showGrid ? "Hide Grid" : "Show Grid"}
                  </button>
                </div>
              </div>

              {/* Drawing Tools */}
              <div className="mb-6">
                <h4 className="font-medium mb-3">Tools</h4>
                <div className="space-y-2">
                  {[
                    { name: "Line", icon: Minus },
                    { name: "Circle", icon: Circle },
                    { name: "Curve", icon: Sparkle }, // Changed to Sparkle
                    { name: "Paintbrush", icon: Paintbrush },
                  ].map((tool) => {
                    const Icon = tool.icon;
                    return (
                      <button
                        key={tool.name}
                        onClick={() => setSelectedTool(tool.name)}
                        onMouseEnter={() => setHoveredTool(tool.name)}
                        onMouseLeave={() => setHoveredTool(null)}
                        className={`w-full flex items-center px-3 py-2 rounded-lg transition-all ${
                          selectedTool === tool.name
                            ? "bg-gradient-to-r from-blue-600 to-cyan-600 text-white shadow-lg"
                            : "bg-gray-100 hover:bg-gray-200"
                        }`}
                      >
                        <Icon className="h-4 w-4 mr-2" />
                        {tool.name}
                      </button>
                    );
                  })}
                </div>
              </div>

              {/* Symmetry */}
              <div className="mb-6">
                <h4 className="font-medium mb-3 flex items-center">
                  <Star className="h-4 w-4 mr-2" />
                  Symmetry
                </h4>
                <div className="space-y-2 mb-3">
                  {["4-fold", "6-fold", "8-fold", "12-fold"].map(
                    // Removed 2-fold
                    (sym) => (
                      <button
                        key={sym}
                        onClick={() => setSelectedSymmetry(sym)}
                        onMouseEnter={() => setHoveredSymmetry(sym)}
                        onMouseLeave={() => setHoveredSymmetry(null)}
                        className={`w-full px-3 py-2 rounded-lg text-sm transition-all ${
                          selectedSymmetry === sym
                            ? "bg-gradient-to-r from-teal-600 to-blue-600 text-white shadow-lg"
                            : "bg-gray-100 hover:bg-gray-200"
                        }`}
                      >
                        {sym}
                      </button>
                    )
                  )}
                </div>
                <button
                  onClick={() => setShowSymmetryLines(!showSymmetryLines)}
                  className={`w-full px-3 py-2 rounded-lg text-sm transition-all ${
                    showSymmetryLines
                      ? "bg-blue-100 text-blue-700"
                      : "bg-gray-100"
                  }`}
                >
                  {showSymmetryLines ? "Hide Guides" : "Show Guides"}
                </button>
              </div>

              {/* Actions */}
              <div className="space-y-2">
                <button
                  onClick={handleUndo}
                  disabled={historyStep === 0}
                  className="w-full flex items-center px-3 py-2 rounded-lg bg-gray-100 hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Undo2 className="h-4 w-4 mr-2" /> Undo
                </button>
                <button
                  onClick={handleRedo}
                  disabled={historyStep === history.length - 1}
                  className="w-full flex items-center px-3 py-2 rounded-lg bg-gray-100 hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  <Redo2 className="h-4 w-4 mr-2" /> Redo
                </button>
                <button
                  onClick={handleClear}
                  className="w-full flex items-center px-3 py-2 rounded-lg bg-red-100 hover:bg-red-200 text-red-700"
                >
                  <RotateCcw className="h-4 w-4 mr-2" /> Clear All
                </button>
              </div>
            </div>
          </div>

          {/* Canvas Area */}
          <div className="lg:col-span-3 space-y-6">
            {/* Canvas */}
            <div className="bg-white rounded-2xl shadow-xl p-6">
              <div className="aspect-square bg-gradient-to-br from-blue-50 to-white border-2 border-dashed border-blue-200 rounded-xl overflow-hidden relative">
                <svg
                  ref={svgRef}
                  viewBox="0 0 500 500"
                  className="w-full h-full cursor-crosshair"
                  onMouseDown={handleMouseDown}
                  onMouseMove={handleMouseMove}
                  onMouseUp={handleMouseUp}
                  onMouseLeave={() => setIsDrawing(false)}
                  style={{ transform: `scale(${zoom})` }}
                >
                  {/* Grid */}
                  {getGridLines(gridNumber)}

                  {/* Symmetry guides */}
                  {getSymmetryLines()}

                  {/* Existing elements */}
                  {elements.map((element) => {
                    if (element.type === "path") {
                      return (
                        <path
                          key={element.id}
                          d={element.d}
                          stroke={element.stroke}
                          strokeWidth={element.strokeWidth}
                          fill={element.fill}
                          strokeLinecap={element.strokeLinecap}
                          strokeLinejoin={element.strokeLinejoin}
                        />
                      );
                    } else if (element.type === "circle") {
                      return (
                        <circle
                          key={element.id}
                          cx={element.cx}
                          cy={element.cy}
                          r={element.r}
                          stroke={element.stroke}
                          strokeWidth={element.strokeWidth}
                          fill={element.fill}
                        />
                      );
                    } else if (element.type === "line") {
                      return (
                        <line
                          key={element.id}
                          x1={element.x1}
                          y1={element.y1}
                          x2={element.x2}
                          y2={element.y2}
                          stroke={element.stroke}
                          strokeWidth={element.strokeWidth}
                          strokeLinecap={element.strokeLinecap}
                        />
                      );
                    }
                    return null;
                  })}

                  {/* Current drawing path / preview for Line/Circle */}
                  {isDrawing && selectedTool === "Curve" && currentPath && (
                    <path
                      d={currentPath}
                      stroke={selectedColor}
                      strokeWidth={brushSize}
                      fill="none"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      opacity="0.8"
                    />
                  )}
                  {isDrawing &&
                    selectedTool === "Paintbrush" &&
                    currentPath && (
                      <path
                        d={currentPath}
                        stroke={selectedColor}
                        strokeWidth={brushSize}
                        fill="none"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        opacity="0.8"
                      />
                    )}
                  {isDrawing && selectedTool === "Line" && (
                    <line
                      x1={mouseDownPoint.x}
                      y1={mouseDownPoint.y}
                      x2={mousePos.x}
                      y2={mousePos.y}
                      stroke={selectedColor}
                      strokeWidth={brushSize}
                      strokeLinecap="round"
                      opacity="0.8"
                    />
                  )}
                  {isDrawing && selectedTool === "Circle" && (
                    <circle
                      cx={mouseDownPoint.x}
                      cy={mouseDownPoint.y}
                      r={Math.sqrt(
                        Math.pow(mousePos.x - mouseDownPoint.x, 2) +
                          Math.pow(mousePos.y - mouseDownPoint.y, 2)
                      )}
                      stroke={selectedColor}
                      strokeWidth={brushSize}
                      fill="none"
                      opacity="0.8"
                    />
                  )}

                  {/* Tool previews */}
                  <AnimatePresence>
                    {(hoveredTool || hoveredSymmetry) && (
                      <g opacity="0.4">
                        {hoveredSymmetry && getSymmetryLines()}
                        {hoveredTool === "Line" && (
                          <line
                            x1="100"
                            y1="250"
                            x2="400"
                            y2="250"
                            stroke="#45b7d1"
                            strokeWidth="2"
                            strokeDasharray="4 2"
                          />
                        )}
                        {hoveredTool === "Circle" && (
                          <circle
                            cx="250"
                            cy="250"
                            r="60"
                            stroke="#45b7d1"
                            strokeWidth="2"
                            fill="none"
                            strokeDasharray="4 2"
                          />
                        )}
                        {(hoveredTool === "Curve" ||
                          hoveredTool === "Paintbrush") && (
                          <path
                            d="M150,300 Q250,150 350,300"
                            stroke="#45b7d1"
                            strokeWidth="2"
                            fill="none"
                            strokeDasharray="4 2"
                          />
                        )}
                      </g>
                    )}
                  </AnimatePresence>
                </svg>

                {/* Empty state */}
                {elements.length === 0 && (
                  <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                    <div className="text-center text-gray-500">
                      <Sparkles className="h-16 w-16 mx-auto mb-4 opacity-30" />
                      <p className="text-lg font-medium mb-2">Start Creating</p>
                      <p className="text-sm">
                        Choose a tool and start drawing your Kolam
                      </p>
                    </div>
                  </div>
                )}
              </div>
            </div>

            {/* Bottom Toolbar */}
            <div className="bg-white rounded-2xl shadow-xl p-4">
              <div className="flex gap-4 justify-between items-center">
                <div className="flex gap-2">
                  <button
                    onClick={() => setZoom(Math.max(0.5, zoom - 0.1))}
                    className="flex items-center px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg"
                  >
                    <ZoomOut className="h-4 w-4 mr-1" />
                    Zoom Out
                  </button>
                  <button
                    onClick={() => setZoom(Math.min(2, zoom + 0.1))}
                    className="flex items-center px-3 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg"
                  >
                    <ZoomIn className="h-4 w-4 mr-1" />
                    Zoom In
                  </button>
                  <span className="px-3 py-2 bg-gray-50 rounded-lg text-sm">
                    {Math.round(zoom * 100)}%
                  </span>
                </div>

                <div className="flex gap-3">
                  <button
                    onClick={() =>
                      alert(
                        "Save functionality would connect to a backend service"
                      )
                    }
                    className="flex items-center px-6 py-2 bg-gradient-to-r from-blue-600 to-cyan-600 text-white rounded-lg shadow-lg hover:shadow-xl transition-all"
                  >
                    <Save className="h-4 w-4 mr-2" /> Save Design
                  </button>
                  <button
                    onClick={handleDownload}
                    className="flex items-center px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg"
                  >
                    <Download className="h-4 w-4 mr-2" /> Download PNG
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Playground;
